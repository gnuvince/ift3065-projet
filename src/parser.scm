;; SINS
;; IFT3065 - H12
;; Vincent Foley-Bourgon (FOLV08078309)
;; Eric Thivierge (THIE09016601)


(include "token.scm")
(include "utilities.scm")
(include "test_lexer.scm")
(include "lexer.scm")
(include "reader.scm")
;;(include "ast.scm")

(define (parse token-list)
  (<program> (sins-read token-list)))

(define (<program> ast)
  (cond ((null? ast)
         ast)
        (else
         (let ((cod (<command-or-definition> (car ast))))
           (if cod
               (cons cod (<program> (cdr ast)))
               (error (string-append "Error in expression:\n"
                                     (with-output-to-string "" (lambda () (write (car ast)))))))))))

(define (<command-or-definition*> ast)
  (cond ((null? ast)
         ast)
        (else
         (<command-or-definition+> ast))))

(define (<command-or-definition+> ast)
  (and (<command-or-definition> (car ast))
       (<command-or-definition*> (cdr ast))
       ast))

(define (<command-or-definition> ast)
  (and
   (or (<command> ast)
       (<definition> ast)
       (begin-com-or-def+ ast))
   ast))

(define (begin-com-or-def+ ast)
  (and (pair? ast)
       (>= (length ast) 2)
       (eq? (car ast) 'begin)
       (<command-or-definition+> (cdr ast))
       ast))

(define (begin-definition* ast)
  (and (pair? ast)
       (eq? (car ast) 'begin)
       (or (= (length ast) 1)
           (<definition*> (cdr ast)))
       ast))

;; ( define <variable>  <expression> )
(define (define-var-expr ast)
  (and (pair? ast)
       (= (length ast) 3)
       (eq? (car ast) 'define)
       (<variable> (cadr ast))
       (<expression> (caddr ast))
       ast))
              
;; ( define ( <variable> <def-formals> ) body )
(define (define-var-formals ast)
  (and (pair? ast)
       (>= (length ast) 3)
       (eq? (car ast) 'define)
       (pair? (cadr ast))
       (<variable> (caadr ast))
       (<def-formals> (cdadr ast))
       (<body> (cddr ast))
       ast))

(define (<def-formals> ast)
  (and (pair? ast)
       (or (null? ast)
           (let ((dotp (member 'dot ast)))
             (and dotp
                  (= (length dotp) 2)
                  (<variable> (cadr dotp))
                  (<variable>* (but-last-n ast 2))))
           (<variable>* ast))
       ast))

(define (<formals> ast)
  (and (or (<variable> ast)
           (and (pair? ast)
                (or (null? ast)
                    (let ((dotp (member 'dot ast)))
                      (and dotp
                           (= (length dotp) 2)
                           (<variable> (cadr dotp))
                           (<variable>+ (but-last-n ast 2))))
                    (<variable>+ ast))))
       ast))

(define (<body> ast)
  (and (not (null? ast))
       (or (<sequence> ast)
           (and (<definition> (car ast))
                (<body> (cdr ast))))
       ast))

(define <sequence> <expression>+)

(define (<definition> ast)
  (and
   (or (define-var-expr ast)
       (define-var-formals ast)
       (begin-definition* ast))
   ast))

(define (<expression>* ast)
  (and (or (null? ast)
           (<expression>+ ast))
       ast))

(define (<expression>+ ast)
  (and (pair? ast)
       (<expression> (car ast))
       (<expression>* (cdr ast))
       ast))

(define (<expression> ast)
  (and 
   (or (<variable> ast)
       (<literal>  ast)
       (<procedure-call> ast)
       (<lambda-expression> ast)
       (<conditional> ast)
       (<assignment> ast)
       (<derived-expression> ast)
       (<macro-use> ast)
       (<macro-block> ast))
   ast))

(define <command> <expression>)

(define (<variable>* ast)
  (and (or (null? ast)
           (and (<variable> (car ast))
                (<variable>* (cdr ast))))
       ast))

(define (<variable>+ ast)
  (and (>= (length ast) 1)
       (<variable> (car ast))
       (<variable>* (cdr ast))
       ast))

(define (<variable> ast)
  (and (symbol? ast)
       ast))
;;  (and (identifier? ast)
;;       (not (symbol? ast))
;;       ast))

(define (identifier? ast)
  (and (not (number? ast))
       (not (string? ast))
       (not (pair? ast))
       ast))

(define (<literal> ast)
  (and 
   (or (<quotation> ast)
       (<self-evaluating> ast))
   ast))

(define (<quotation> ast)
  #f)

(define (<self-evaluating> ast)
  (and
   (or (<boolean> ast)
       (<number> ast)
       (<character> ast)
       (<string> ast))
   ast))

(define (<boolean> ast)
  (and
   (or (eq? ast #t)
       (eq? ast #f))
   ast))

(define (<number> ast)
  (and (number? ast)
       ast))

;;(define (<character> ast)
;;  #f)
(define (<character> ast)
  (and (char? ast)
       ast))

(define (<string> ast)
  (and (string? ast)
       ast))

;;(define (<procedure-call> ast)
;;  #f)
(define (<procedure-call> ast)
  (and (pair? ast)
       (>= (length ast) 1)
       (<operator> (car ast))
       (<operand>* (cdr ast))
       ast))

(define (<operator> ast)
  (and (not (member ast keywords))
       (<expression> ast)
       ast))

(define <operand> <expression>)

(define (<operand>* ast)
  (and (or (null? ast)
           (and (<operand> ast)
                (<operand>* (cdr ast))))
       ast))

(define (<lambda-expression> ast)
  (and (pair? ast)
       (= (length ast) 3)
       (eq? (car ast) 'lambda)
       (<formals> (cadr ast))
       (<body> (caddr ast))
       ast))

(define (<conditional> ast)
  (and (pair? ast)
       (eq? (car ast) 'if)
       (member (length ast) '(3 4))
       (<expression> (cadr ast))
       (<expression> (caddr ast))
       (or (null? (cdddr ast))
           (<expression> (cdddr ast)))
       ast))

(define (<assignment> ast)
  (and (pair? ast)
       (eq? (car ast) 'set!)
       (= (length ast) 3)
       (<variable> (cadr ast))
       (<expression> (caddr ast))
       ast))

(define (<derived-expression> ast)
  (and (pair? ast)
       (or (<quasiquotation> ast)
           (cond-derived-expression ast)
           (and-derived-expression ast)
           (or-derived-expression ast)
           (let-derived-expression ast)
           (let*-derived-expression ast)
           (letrec-derived-expression ast)
           (begin-derived-expression ast)
           (do-derived-expression ast)
           (delay-derived-expression ast)
           (case-derived-expression ast))
       ast))

(define (<quasiquotation> ast)
  (and (or (eq? (car ast) 'backquote)
           (eq? (car ast) 'quasiquote))
       ast))

(define (cond-derived-expression ast)
  (and (pair? ast)
       (eq? (car ast) 'cond)
       (cond-clauses (cdr ast))
       ast))

(define (cond-clauses ast)
  (and (if (cond-else-clause (car ast))
           (null? (cdr ast))
           (and (<cond-clause> (car ast))
                (or (null? (cdr ast))
                    (cond-clauses (cdr ast)))))
       ast))

(define (cond-else-clause ast)
  (and (pair? ast)
       (eq? (car ast) 'else)
       (<sequence> (cdr ast))
       ast))

(define (<cond-clause> ast)
  (and (pair? ast)
       (<test> (car ast))
       (or (null? (cdr ast))
           (and (eq? (cadr ast) '=>)
                (<recipient> (caddr ast)))
           (<sequence> (cdr ast)))
       ast))

(define <test> <expression>)

(define <recipient> <expression>)

(define (and-derived-expression ast)
  (and (pair? ast)
       (eq? (car ast) 'and)
       (<expression>* (cdr ast))
       ast))

(define (or-derived-expression ast)
  (and (pair? ast)
       (eq? (car ast) 'or)
       (<expression>* (cdr ast))
       ast))

(define (let-derived-expression ast)
  (and (pair? ast)
       (eq? (car ast) 'let)
       (>= (length ast) 3)
       (or (and (<variable> (cadr ast))
                (>= (length (cddr ast)) 2)
                (<binding-spec>* (caddr ast))
                (<body> (cdddr ast)))
           (and (<binding-spec>* (cadr ast))
                (<body> (cddr ast))))
       ast))

(define (let*-derived-expression ast)
  (and (pair? ast)
       (eq? (car ast) 'let*)
       (>= (length ast) 3)
       (<binding-spec>* (cadr ast))
       (<body> (cddr ast))
       ast))

(define (letrec-derived-expression ast)
  (and (pair? ast)
       (eq? (car ast) 'letrec)
       (>= (length ast) 3)
       (<binding-spec>* (cadr ast))
       (<body> (cddr ast))
       ast))

(define (<binding-spec>* ast)
  (and (or (null? ast)
           (and (pair? ast)
                (<binding-spec> (car ast))
                (<binding-spec>* (cdr ast))))
       ast))

(define (<binding-spec> ast)
  (and (pair? ast)
       (= (length ast) 2)
       (<variable> (car ast))
       (<expression> (cadr ast))
       ast))

(define (begin-derived-expression ast)
  #f)

(define (do-derived-expression ast)
  #f)

(define (case-derived-expression ast)
  #f)

(define (delay-derived-expression ast)
  #f)

(define (<macro-use> ast)
  #f)

(define (<macro-block> ast)
  #f)
